/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.example.hillcipher;

import com.google.common.annotations.VisibleForTesting;

import static com.example.hillcipher.Util.printMatrix;
import static com.example.hillcipher.Util.resetMatrix;

public class App {
    private static final int[][] keyMatrix = new int[][]{{1, 2, 1}, {2, 3, 2}, {2, 2, 1}};
    private static final int[][] keyMatrixInverse = new int[][]{{-1, 0, 1}, {2, -1, 0}, {-2, 2, -1}};

    private static final int[][] keyMatrix2 = new int[][]{{2, 8, 15}, {7, 4, 17}, {8, 13, 6}};
    private static final int[][] keyMatrix2Inverse = new int[][]{{3, 7, 16}, {2, 6, 17}, {9, 8, 20}};

    private static final int[][] keyMatrix3 = new int[][]{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
    private static final int[][] keyMatrix3Inverse = new int[][]{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};

    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        final App app = new App();
        app.hillCipher("WEKILLTONIGHT");
    }

    public void hillCipher(final String message) {
        int n = 3;
        String paddedMessage = message;
        if (message.length() % n != 0) { // Should pad
            for (int i = 0; i < (n - (message.length() % n)); i++) {
                paddedMessage += 'X';
            }
        }

        String cipher = "";
        for (int i = 0; i < message.length(); i += 3) {
            cipher += hash(keyMatrix3,
                    paddedMessage.charAt(i),
                    paddedMessage.charAt(i + 1),
                    paddedMessage.charAt(i + 2));
        }
        System.out.println("Hill Cipher demonstration");
        System.out.printf("Original message     : %s\n", message);
        System.out.printf("Padded message       : %s\n", paddedMessage);
        System.out.printf("Encrypted            : %s\n", cipher);

        String decrypted = "";
        for (int i = 0; i < cipher.length(); i += 3) {
            decrypted += hash(
                    keyMatrix3Inverse,
                    cipher.charAt(i),
                    cipher.charAt(i + 1),
                    cipher.charAt(i + 2));
        }
        System.out.printf("Decrypted            : %s\n", decrypted);
    }

    private String hash(int[][] key, char a, char b, char c) {
        String ret = "";
        int hashedA = (int) a % 65;
        int hashedB = (int) b % 65;
        int hashedC = (int) c % 65;

        int x = (hashedA * key[0][0] + hashedB * key[0][1] + hashedC * key[0][2]) % 26;
        int y = (hashedA * key[1][0] + hashedB * key[1][1] + hashedC * key[1][2]) % 26;
        int z = (hashedA * key[2][0] + hashedB * key[2][1] + hashedC * key[2][2]) % 26;

        ret += (char) (x + 65);
        ret += (char) (y + 65);
        ret += (char) (z + 65);
        return ret;
    }
}


/**
 * A 3x3 key matrix implementation of Hill Cipher Algorithm.
 */
class HillCipher {
    private static final char PAD_VALUE = 'X';

    private final int[][] keyMatrix;
    private HillCipher(final int[][] keyMatrix) {
        this.keyMatrix = keyMatrix;
    }

    /**
     * c = k * p * mod26
     * @param message - The message to be encrypted
     * @return - The encrypted cipher text.
     */
    public String encrypt(final String message) {
        int n = 3; // Since, it's a 3x3 matrix mode

        String paddedMessage = message;
        if (message.length() % n != 0) { // Should pad
            for (int i = 0; i < (n - (message.length() % n)); i++) {
                paddedMessage += PAD_VALUE;
            }
        }

        final char[] messageArr = paddedMessage.toCharArray();
        int[][] messageVector = new int[3][1];

        System.out.printf("Original message=%s\n", message);
        System.out.printf("Padded message=%s\n", paddedMessage);

        String cipherText = "";
        int k = 0;
        for (int i = 0; i < messageArr.length / n; i++) {
            resetMatrix(messageVector);

            for (int j = 0; j < n; j++) {
                messageVector[j][0] = messageArr[k] % 65;
                k++;
            }

            // process the messageVector c = (keyMatrix * messageVector) * mod26
            int[][] c = new int[3][1];
            multiply(keyMatrix, messageVector, /* out= */ c);
            modulo(c, 26);

            for (int[] chatInts : c) {
                cipherText += (char) (chatInts[0] + 65);
            }
        }
        System.out.printf("Cipher: %s\n", cipherText);
        return cipherText;
    }

    public String decrypt() {
        throw new UnsupportedOperationException("Unable to decrypt");
    }

    private void multiply(int[][] a, int[][] b, int[][] out) {
        if (b.length != a.length) {
            throw new RuntimeException("Unable to perform multiplication");
        }

        int i, j, k;
        // Multiply the two matrices
        int row1 = a.length, col2 = b[0].length, row2 = b.length;
        for (i = 0; i < row1; i++) {
            for (j = 0; j < col2; j++) {
                for (k = 0; k < row2; k++)
                    out[i][j] += a[i][k] * b[k][j];
            }
        }
    }

    private void modulo(int[][] in, int mod) {
        for (int i = 0; i < in.length; i++) {
            for (int j = 0; j < in[0].length; j++) {
                in[i][j] = in[i][j] % mod;
            }
        }
    }

    public static class Factory {
        HillCipher create(String key) throws IllegalArgumentException {
            if (key.toUpperCase().length() % 3 != 0) {
                throw new IllegalArgumentException("Invalid key length");
            }
            if (!key.toUpperCase().matches("^[A-Z]*$")) {
                throw new IllegalArgumentException("Key only contains alphabets");
            }

            final int[][] keyMatrix = new int[3][3];
            getKeyMatrix(key, keyMatrix);
            System.out.println("Key matrix:");
            printMatrix(keyMatrix);
            return new HillCipher(keyMatrix);
        }

        HillCipher create(int[][] keyMatrix) {
            return new HillCipher(keyMatrix);
        }

        @VisibleForTesting
        public static void getKeyMatrix(String key, int[][] outKeyMatrix) {
            int k = 0;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    outKeyMatrix[i][j] = (key.charAt(k)) % 65;
                    k++;
                }
            }
        }

        @VisibleForTesting
        public static String getKeyFromMatrix(int[][] outKeyMatrix) {
            String key = "";
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    key += (char) (outKeyMatrix[i][j] + 65);
                }
            }
            return key;
        }
    }
}